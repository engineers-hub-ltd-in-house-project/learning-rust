/*
 * スライスの基本
 *
 * この例では、Rustのスライス（slice）の基本的な使い方を示しています。
 * スライスは配列やベクタなどのコレクションの一部を参照する型です。
 *
 * スライスの特徴：
 * 1. コレクションの連続した部分を参照する
 * 2. コレクションの所有権を持たない（借用のみ）
 * 3. 不変参照（&[T]）と可変参照（&mut [T]）の2種類がある
 * 4. [開始位置..終了位置] という構文で作成する
 *
 * この例では、文字列スライス（&str）を使用して、文字列の一部を参照しています。
 */

fn main() {
    // 文字列を作成（型注釈を明示）
    let message: String = String::from("こんにちは世界");

    // 文字列全体のスライス（型注釈を明示）
    let whole_slice: &str = &message[..];
    println!("全体のスライス: {}", whole_slice);

    // 部分スライス: 境界に注意（UTF-8の文字境界に合わせる必要がある）
    // UTF-8では日本語の文字は3バイトなので、インデックスは文字単位ではなくバイト単位
    // ここでは簡単のため、文字数 * 3 でインデックスを計算している
    let hello_slice: &str = &message[0..15]; // 「こんにちは」の部分（5文字 * 3バイト）
    println!("「こんにちは」のスライス: {}", hello_slice);

    // 開始位置や終了位置の省略（型注釈を明示）
    let from_start: &str = &message[..6]; // 先頭から2文字目まで
    let to_end: &str = &message[3..]; // 2文字目から末尾まで

    println!("先頭から2文字目まで: {}", from_start);
    println!("2文字目から末尾まで: {}", to_end);

    // 数値配列とそのスライスの例
    let numbers: [i32; 5] = [10, 20, 30, 40, 50];

    // 配列のスライス（型注釈を明示）
    let slice1: &[i32] = &numbers[1..4]; // インデックス1から3までの要素
    println!("数値スライス: {:?}", slice1);

    // スライスの長さ
    let slice_len: usize = slice1.len();
    println!("スライスの長さ: {}", slice_len);

    // スライスの要素にアクセス
    let second_elem: i32 = slice1[1]; // スライスのインデックス1（元の配列では2）
    println!("スライスの2番目の要素: {}", second_elem);
}
